// THIS FILE GENERATED BY Nickel
// https://github.com/Nathan-Fenner/Ni
// <prelude>

#include "stdio.h"
#include "math.h"
#include "stdlib.h"

typedef struct {
	void (*function)(); // function pointer of function to Invoke()
	int capacity; // number of arguments total needed to invoke. 0 <= capacity
	int applied; // number of elements in arguments (applied <= capacity)
	Value * arguments; // an array of [capacity] arguments
} PartialValue;

typedef struct {
	Value * left;
	Value * right;
} CallValue;

typedef enum {false, true} bool;

typedef enum {UNIT, VOID, BANG, PARTIAL, CALL, INTEGER}

typedef union {
	void * value;
	void (*function)();
	PartialValue partial;
	int intValue;
	CallValue call;
} ValueData;

typedef struct {
	int kind;
	ValueData data;
} Value;

typedef struct {
	int n;
	char ** names;
	void * values;
} TypeDescription;

const Value Unit = {UNIT};
const Value Void = {VOID};
const Value Bang = {BANG};

Value Call(Value partial, int argc, Value * argv) {
	Value call;
	call.data.call.left = malloc(sizeof(Value));
	*call.data.call.left = partial;
	call.data.call.right = malloc(sizeof(Value) * argc);
	memcpy(call.right, argv, sizeof(Value) * argc);
	return call;
}

Value Invoke(PartialValue function, int argc, Value * argv) {
#include "invokebody.c"
}

Value Force(Value value) {
	switch (value.kind) {
	case PARTIAL:
		if (value.data.partial.applied == value.data.partial.capacity) {
			return Invoke(value.data.partial.function, value.data.partial.applied, value.data.partial.arguments);
		} else {
			return value;
		}
	}
	return value;
}

Value Partial(void (*function)(), int capacity, int argc, Value * argv) {
	Value v;
	v.kind = PARTIAL;
	v.data.partial.function = function;
	v.data.partial.capacity = capacity;
	v.data.partial.arguments = malloc(sizeof(Value) * capacity); // TODO: fix leak
	return Call(v, argc, argv);
}

Value Constructor(const char * name, int len, const char ** names, Value * values) {

}

Value Dot(Value left, const char * field) {

}

// value must be forced
bool Bool(Value value) {
	// assert value.kind == INTEGER
	return value.data.intValue;
}

// value must be forced
int Integer(Value value) {
	// assert value.kind == INTEGER
	return value.data.intValue;
}


// <operators>
// int + int
Value OperatorPlus(Value left, Value right) {
	Value v;
	v.kind = INTEGER;
	v.data.integer = Integer(Force(left)) + Integer(Force(right));
	return v;
}

// int == int
Value OperatorEqualsEquals(Value left, Value right) {
	Value v;
	v.kind = INTEGER;
	v.value = Integer(Force(left)) == Integer(Force(right));
	return v;
}
// </operators>

// </prelude>
