// THIS FILE GENERATED BY Nickel
// https://github.com/Nathan-Fenner/Ni
// <prelude>

#include "stdio.h"
#include "math.h"
#include "stdlib.h"
#include "string.h"

struct Value;

typedef struct Value Value;

typedef struct {
	void (*function)(); // function pointer of function to Invoke()
	int capacity; // number of arguments total needed to invoke. 0 <= capacity
	int applied; // number of elements in arguments (applied <= capacity)
	Value * arguments; // an array of [capacity] arguments
} PartialValue;

typedef struct {
	Value * fun;
	Value * args;
	int argCount;
} CallValue;

typedef enum {false, true} bool;

typedef enum {NO_TYPE, UNIT, BANG, PARTIAL, CALL, INTEGER} KIND;

typedef union {
	void * value;
	void (*function)();
	PartialValue partial;
	int intValue;
	CallValue call;
} ValueData;

struct Value {
	int kind;
	ValueData data;
};

typedef struct {
	int n;
	char ** names;
	void * values;
} TypeDescription;

const Value Unit = {UNIT};
const Value Bang = {BANG};

Value Call(Value fun, int argCount, Value * args) {
	Value call = {CALL};
	call.data.call.fun = malloc(sizeof(Value));
	*call.data.call.fun = fun;
	call.data.call.args = malloc(sizeof(Value) * argCount);
	memcpy(call.data.call.args, args, sizeof(Value) * argCount);
	call.data.call.argCount = argCount;
	return call;
}

Value Invoke(PartialValue function, int argc, Value * argv) {
#include "invokebody.c"
}

Value Force(Value value) {
	switch (value.kind) {
	case PARTIAL:
		if (value.data.partial.applied == value.data.partial.capacity) {
			return Force(Invoke(value.data.partial.function, value.data.partial.applied, value.data.partial.arguments));
		} else {
			return value;
		}
	case CALL:
		Value fun = Force(*value.data.call.fun);
		if (value.data.call.argCount == 0) {
			return fun;
		}
		if (fun.kind != PARTIAL) {
			printf("evaluating this function produced kind = %d, not the expected %d", fun.kind, PARTIAL);
			exit(-1);
		}
		Value copy = fun;
		copy.data.partial.arguments = malloc(sizeof(Value) * copy.data.partial.capacity); // TODO: memory leak
		memcpy(copy.data.partial.arguments, fun.data.partial.arguments, sizeof(Value) * fun.data.partial.applied);
		copy.data.partial.arguments[fun.data.partial.applied++] = value.data.call.args[0];
		
		Value *copyPointer = malloc(sizeof(Value));
		*copyPointer = copy; // TODO: memory leak

		Value tail;
		tail.kind = CALL;
		tail.data.call.fun = copyPointer;
		tail.data.call.args = value.data.call.args + 1;
		tail.data.call.argCount =  value.data.call.argCount-1;

		return Force(tail);
	case UNIT:
	case BANG:
	case INTEGER:
		return value;
	}
	return value;
}

Value Partial(void (*function)(), int capacity, int argc, Value * argv) {
	Value v;
	v.kind = PARTIAL;
	v.data.partial.function = function;
	v.data.partial.capacity = capacity;
	v.data.partial.arguments = malloc(sizeof(Value) * capacity); // TODO: fix leak
	return Call(v, argc, argv);
}

Value Constructor(const char * name, int len, const char ** names, Value * values) {

}

Value Dot(Value left, const char * field) {

}

// value must be forced
bool Bool(Value value) {
	// assert value.kind == INTEGER
	return value.data.intValue;
}

// value must be forced
int Integer(Value value) {
	// assert value.kind == INTEGER
	return value.data.intValue;
}


// <operators>
// int + int
Value OperatorPlus(Value left, Value right) {
	Value v;
	v.kind = INTEGER;
	v.data.integer = Integer(Force(left)) + Integer(Force(right));
	return v;
}

// int == int
Value OperatorEqualsEquals(Value left, Value right) {
	Value v;
	v.kind = INTEGER;
	v.value = Integer(Force(left)) == Integer(Force(right));
	return v;
}
// </operators>

// <built-in>

Value _print(Value number, Value bang) {
	int q = Integer(Force(number));
	printf("%d\n", q);
	return Unit;
}

// </built-in>

// </prelude>